<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <title>Coq: jak udowodnić, że nasz program działa poprawnie</title>

    <!-- important: this will not work from *within* the jsCoq package dir; -->
    <!-- this template is meant to be copied to your project dir and edited -->
    <script src="ui-js/jscoq-loader.js"></script>
  </head>

<body class="jscoq-main">
  <div id="ide-wrapper" class="toggled">
    <div id="code-wrapper">
      <div id="document">
        <h1>Coq: jak udowodnić, że nasz program działa poprawnie</h1>
        <textarea id="coq-code">
(** * Coq a inne języki programowania *)

(** Coq jest mocno wyjątkowym językiem programowania, różniącym się znacznie
    od większości popularnych języków, jak C++ czy Python.
    
    Po pierwsze, Coq jest językiem funkcyjnym. Zamiast zmiennych globalnych,
    dajemy funkcjom dodatkowe argumenty. Zamiast iterować po strukturach
    danych zrobionych ze wskaźników, przemierzamy drzewa za pomocą funkcji
    rekurencyjnych - czyli takich, które wywołują same siebie. Zamiast wielkich
    pętli przetwarzających dane, budujemy duże funkcje składając ze sobą wiele
    małych funkcji. Nasze funkcje mogą brać inne funkcje jako argumenty oraz
    zwracać funkcje jako wynik.
    
    Jednak jest coś jeszcze, co odróżnia Coqa nawet od prawie wszystkich
    innych języków funkcyjnych. Mianowicie, Coq pozwala na formalną weryfikację
    poprawności napisanych w nim programów - najpierw piszemy program, a potem
    dowodzimy twierdzenia mówiącego, że program działa tak jak powinien. Gdy
    programujemy w Coqu, możemy (i powinniśmy!) być jednocześnie matematykiem. *)

(** * Proste typy i funkcje *)

Inductive          (* Definicja typu zaczynaja się od słowa kluczowego "Inductive". *)
  bit : Type :=    (* "bit" jest typem *)
    | tak : bit    (* "tak" jest elementem typu "bit" *)
    | nie : bit    (* "nie" jest elementem typu "bit" *)
    .              (* Definicje czegokolwiek w Coqu zazwyczaj kończą się kropką. *)

Definition                  (* Definicja zaczyna się od słowa kluczowego "Definition" *)
  negacja : bit -> bit :=    (* "negacja" to funkcja, która bierze bit i zwraca bit *)
    fun b : bit =>             (* Weź jako argument bit nazwany "b". *)
      match b with          (* Sprawdźmy, jakiej "b" jest postaci. *)
          | tak => nie       (* Gdy "b" to "tak", wynikiem funkcji jest "nie". *)
          | nie => tak       (* Gdy "b" to "nie", wynikiem funkcji jest "tak". *)
      end.                  (* Koniec definicji. *)

(** * Równość, obliczenia i proste twierdzenia *)

Goal tak = tak. (* Po słowie kluczowym "Goal" piszemy, co chcemy udowodnić. *)
Proof.          (* Dowód zaczynamy od słowa kluczowego "Proof". *)
  reflexivity.  (* Każda rzecz jest równa samej sobie i Coq o tym wie. *)
Qed.            (* Dowód kończymy słowem "Qed" - od łac. "Quod erat demonstrandum" - "Co należało udowodnić" *)

Goal tak = nie.
Proof.
  Fail reflexivity. (* "tak" to coś innego niż "nie" i Coq to wie - nie da się go zrobić w wała *)
Abort.              (* Zakończenie dowodu za pomocą "Abort" oznacza, że się poddajemy. *) 

Goal negacja tak = nie.
Proof.
  cbv delta.   (* Pierwszym krokiem obliczeń jest odwinięcie definicji. *)
  cbn beta.    (* Kolejnym krokiem jest podstawienie wartości "tak" za argument funkcji. *)
  cbn iota.    (* Ostatnim krokiem jest wykonanie dopasowania i zwrócenie odpowiedniej wartości. *)
  reflexivity. 
Qed.

Goal negacja nie = tak.
Proof.
  cbv. (* Oczywiście można obliczyć wszystko za jednym zamachem. *)
  reflexivity.
Qed.

Goal forall b : bit, negacja (negacja b) = b.
Proof.
  intro dowolne_b.    (* Weźmy dowolny bit *)
  case dowolne_b.     (* Analiza przypadków: bit może mieć jedną z dwóch postaci (tak/nie) *)
    cbv. reflexivity. (* Trochę obliczeń i... udało się! *)
    reflexivity.      (* Nie musimy ręcznie prosić o policzenie - Coq sam wie, żeby to zrobić. *)
Qed.

(** * Bardziej skomplikowane typy, funkcje rekurencyjne i dowody przez indukcję *)

Inductive lista : Type :=
    | koniec      : lista                (* "koniec" jest listą *)
    | na_początku : bit -> lista -> lista. (* na_początku b l jest listą, pod warunkiem że b jest bitem a l listą *)

(* [tak; nie; tak] *)
Check na_początku tak (na_początku nie (na_początku tak koniec)).

Fixpoint na_końcu (b : bit) (l : lista) : lista :=         (* Definicje rekurencyjne zaczynają się od "Fixpoint". *)
match l with
    | koniec           => na_początku b koniec
    | na_początku c l' => na_początku c (na_końcu b l')
end.

Fixpoint odwróć (l : lista) : lista :=
match l with
    | koniec           => koniec
    | na_początku b l' => na_końcu b (odwróć l')
end.

Theorem odwróć_na_końcu :
  forall (b : bit) (l : lista),
    odwróć (na_końcu b l) = na_początku b (odwróć l).
Proof.
  intro b. (* Weźmy dowolne b. *)
  induction l as [| głowa_l ogon_l hipoteza_indukcyjna].
     cbv. reflexivity.
     cbn. rewrite hipoteza_indukcyjna. cbn. reflexivity.
Qed.

Theorem odwróć_odwróć :
  forall l : lista,
    odwróć (odwróć l) = l.
Proof.
  induction l as [| głowa_l ogon_l hipoteza_indukcyjna].
    cbn. reflexivity.
    cbn. rewrite odwróć_na_końcu. rewrite hipoteza_indukcyjna.
      reflexivity.
Qed.

(** * Ćwiczenia *)

(** Zdefiniuj funkcję lub : bit → bit → bit, która zwraca "tak", gdy co najmniej jeden
    z jej argumentów jest równy "tak", zaś "nie" w przeciwnym wypadku.
    
    Następnie udowodnij, że:
    1. ∀ a : bit, lub a a = a.
    2. ∀ a : bit, lub a (negacja a) = tak.
    3. ∀ a b : bit, lub a b = lub b a.
    4. ∀ a b c : bit, lub (lub a b) c = lub a (lub b c)
    
    Co się stanie, gdy zanegujemy lub, tzn. czemu jest równe "negacja (lub a b)"?
    
    Zdefiniuj funkcję sklej : lista → lista → lista, które bierze dwie listy i
    skleja je ze sobą, np.
    
    sklej (na_początku tak koniec) (na_początku nie koniec)
    =
    na_początku tak (na_początku nie koniec).
    
    Następnie udowodnij następujące twierdzenia:
    1. ∀ l : lista, sklej koniec l = l
    2. ∀ l : lista, sklej l koniec = l
    3. ∀ l1 l2 l3 : lista, sklej (sklej l1 l2) l3 = sklej l1 (sklej l2 l3)
    4. ∀ (b : bit) (l1 l2 : lista), na_końcu b (sklej l1 l2) = sklej l1 (na_końcu b l2)
    5. ∀ l1 l2 : lista, odwróć (sklej l1 l2) = sklej (odwróć l2) (odwróć l1) *)

(** * Dlaczego warto nauczyć się Coqa? *)

(** Języki funkcyjne ekspandują. *)

(** * Kim jesteśmy, dokąd zmierzamy? *)

(** Najłatwiej jest zapoznać się z Coqiem używając przeglądarkowego środowiska
    jsCoq (https://jscoq.github.io/scratchpad.html). Polecam - nie trzeba nic
    instalować i ma rozsądne podpowiadanie składni dla początkujących.

    Jeżeli chcecie zacząć dłuższą przygodę z Coqiem, polecam go zainstalować
    (https://coq.inria.fr/) - śmiga wtedy lepiej niż w przeglądarce. Musicie
    też wybrać sobie jakieś IDE:
    1. CoqIDE (https://coq.inria.fr/) - standardowe IDE do Coqa, polecam.
    2. Visual Studio Code (https://code.visualstudio.com/) z pluginem dla
       Coqa - również całkiem spoko.
    3. Emacs (https://www.gnu.org/software/emacs/) z pluginem Proof General
       (https://proofgeneral.github.io/) - nie polecam.
    4. W ostateczności można też używać Coqa z poziomu konsoli, ale tym
       bardziej nie polecam.

    Przyda się też troche materiałów dydaktycznych:
    1. Nagranie z zeszłorocznych dni otwartych (po polsku, ok. 20 min):
       https://www.youtube.com/watch?v=njgUPWlWYUM&t=6936s
    2. Nagranie z prezentacji podobnej do naszej (po angielsku, 3 godziny):
       https://www.youtube.com/watch?v=5e7UdWzITyQ
    3. Książka Software Foundations, pierwsza połowa pierwszego tomu
       (po angielsku): https://softwarefoundations.cis.upenn.edu/lf-current/toc.html
    
    Jeżeli słuchanie/czytanie po angielsku sprawia wam problem, możecie też przeczytać
    pierwsze rozdziały mojej własnej twórczości: https://wkolowski.github.io/CoqBookPL/
    (uwaga, dość niekompletna i trochę nie po kolei).
    
    Przydatne linki:
    1. Strona domowa: https://coq.inria.fr/
    2. GitHub: https://github.com/coq/coq
    3. Forum: https://coq.discourse.group/
    4. Czat: https://coq.zulipchat.com/login/
    5. Q&A: https://stackoverflow.com/questions/tagged/coq
    
    Jeżeli macie pytania, piszcie (asekuracyjnie podaje uczelniane maile):
    1. Ja: 299899@uwr.edu.pl
    2. Nie ja: tomasz.drab@cs.uni.wroc.pl *)
        </textarea>
      </div>
    </div>
  </div>

  <!-- jsCoq configuration part -->
  <script type="text/javascript">

    var jscoq_ids  = ['coq-code'];
    var jscoq_opts = {
        prelude:   true,
        base_path: './',
        editor:    { mode: { 'company-coq': true }, keyMap: 'default' },
        init_pkgs: ['init'],
        all_pkgs:  ['coq']
    };

    JsCoq.start(jscoq_opts.base_path, './', jscoq_ids, jscoq_opts);
  </script>
</body>
