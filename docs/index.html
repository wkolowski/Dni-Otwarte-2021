<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Coq: jak udowodnić, że nasz program działa poprawnie</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Coq: jak udowodnić, że nasz program działa poprawnie</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 Cześć, nazywam się Wojciech Kołowski i witam cię na Dniach Otwartych
    Instytutu Informatyki UWr 2021. Wszystkie materiały z tego wydarzenia
    możesz znaleźć tutaj: https://ii.uni.wroc.pl/dla-studenta/drzwi-otwarte,
    ja natomiast opowiem ci dziś o języku programowania Coq. 
<div class="paragraph"> </div>

<a id="lab1"></a><h1 class="section">Coq a inne języki programowania</h1>

<div class="paragraph"> </div>

 Coq (wymawiane "kok"; nazwa pochodzi od francuskiego słowa "coq",
    oznaczającego koguta) jest mocno wyjątkowym językiem programowania,
    różniącym się znacznie od większości popularnych języków, jak C++ czy
    Python.

<div class="paragraph"> </div>

    Coq jest przede wszystkim językiem funkcyjnym. Funkcje są podstawowym
    budulcem wszystkich programów i cieszą się niespotykaną w mainstreamowych
    językach elastycznością - mogą brać inne funkcje jako argumenty, zwracać
    funkcje jako wynik, i tak dalej. W Coqu (i w ogóle w językach funkcyjnych)
    większość rzeczy robimy inaczej, niż w innych językach programowania:
<ul class="doclist">
<li> Zamiast zmiennych globalnych, dajemy funkcjom dodatkowe argumenty.

</li>
<li> Zamiast iterować po strukturach danych zrobionych ze wskaźników,
      przemierzamy drzewa za pomocą funkcji rekurencyjnych (czyli takich,
      które wywołują same siebie).

</li>
<li> Zamiast wielkich pętli przetwarzających dane, budujemy duże funkcje
      składając ze sobą wiele małych funkcji.

</li>
<li> Różnic jest więcej, ale nie sposób wszystkich ich tutaj wymienić.

</li>
</ul>

<div class="paragraph"> </div>

    Jednak jest coś jeszcze, co odróżnia Coqa nawet od pozostałych języków
    funkcyjnych. Mianowicie, Coq pozwala na formalną weryfikację poprawności
    napisanych w nim programów... ale co to właściwie znaczy? W zwykłych
    językach, jak Python czy C++, w zasadzie jedyną możliwością sprawdzenia,
    czy napisany przez nas program działa tak jak chcemy, są testy. Pojedynczy
    test uruchamia nasz program dla jakichś konkretnych danych wejściowych i
    sprawdza, czy wynik jest taki jak się spodziewamy. Jeżeli napiszemy dużo
    testów i wszystkie one kończą się pomyślnie, to uznajemy, że nasz program
    jest poprawny.

<div class="paragraph"> </div>

    Takie podejście jako tako sprawdza się w praktyce, ale nie daje pełnych i
    niepodważalnych gwarancji poprawności. Wszak, jak powiedział niegdyś klasyk
    informatyki, "testy mogą wykazać obecność błędów w programie, ale nie mogą
    wykazać ich nieobecności". Coq zaś wykazanie nieobecności błędów umożliwia:
    najpierw piszemy program, a potem dowodzimy twierdzenia, które mówi, że
    program działa tak jak powinien. Pisząc "twierdzenia" mam na myśli rzeczy
    analogiczne do tych znanych ci z lekcji matematyki, jak twierdzenie
    Pitagorasa, tylko że dotyczące programów, a pisząc "dowodzimy" mam na myśli
    czynność analogiczną do tej, którą wykonuje matematyk, aby upewnić się, że
    twierdzenie Pitagorasa jest prawdziwe. Wynik jest również analogiczny: tak
    jak twierdzenie Pitagorsa jest prawdziwe i nie ma co do tego najmniejszych
    wątpliwości ani nie da się go w żaden sposób podważyć, tak też twierdzenie
    o poprawności naszego programu, gdy je udowodnimy, gwarantuje nam, że w
    programie na pewno nie ma błędów.

<div class="paragraph"> </div>

    Morał tej bajki jest prosty: gdy programujemy w Coqu, możemy (i powinniśmy!)
    być jednocześnie matematykiem. 
<div class="paragraph"> </div>

<a id="lab2"></a><h1 class="section">Środowisko jsCoq</h1>

<div class="paragraph"> </div>

 Środowisko, którego aktualnie używamy, nazywa się jsCoq. Jest fajne, bo
    pozwala używać Coqa bezpośrednio w przeglądarce i nie trzeba niczego
    instalować.

<div class="paragraph"> </div>

    Interakcja z Coqiem przebiega następująco. Po lewej mamy tekst poprzeplatany
    polami tekstowymi zawierającymi kod (można ten kod edytować - zachęcam do
    zabawy). Po prawej na dole jest okno, w którym Coq wyświetla nam informacje
    diagnostyczne, wiadomości o błędach i odpowiedzi na nasze zapytania. W oknie
    po prawej na górze póki co nie ma nic ciekawego - uaktywni się ono dopiero, gdy
    będziemy chcieli czegoś dowodzić.

<div class="paragraph"> </div>

    Po prawej na samej górze mamy kilka strzałek, którymi mówimy Coqowi,
    co ma robić (możemy też używać skrótów klawiszowych). Strzałka w dół
    (skrót: alt + strzałka w dół) - "wczytaj następny kawałek kodu",
    strzałka w górę (skrót: alt + strzałka w górę) - "cofnij się do
    poprzedniego kawałka kodu", podwójna strzałka (skrót: alt + enter) -
    "wczytaj cały kod aż do miejsca, w którym znajduje się kursor".

<div class="paragraph"> </div>

    Ok, tyle tytułem wstępu. Czas zobaczyć w końcu jakiś przykład! 
<div class="paragraph"> </div>

<a id="lab3"></a><h1 class="section">Proste typy i funkcje</h1>

<div class="paragraph"> </div>

 Wiesz pewnie, co to bit. Otóż bit to takie coś co może być zerem lub
    jedynką. Spróbujmy zaimplementować w Coqu typ reprezentujący bity,
    napisać jakąś funkcję i coś o niej udowodnić. Uwaga: "0" i "1" nie są
    legalnymi nazwami w Coqu, więc nasze bity musimy nazwać jakoś inaczej.
    Przyjmijmy nazwy <span class="inlinecode"><span class="id" title="var">tak</span></span> i <span class="inlinecode"><span class="id" title="var">nie</span></span>. Uwaga 2: tekst pomiędzy znacznikami "( *"
    oraz "* )" to komentarze. Po każdej linijce kodu, która wprowadza jakąś
    nowość, będę umieszczał komentarze tłumaczące, co dana linijka oznacza. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span>        <span class="comment">(*&nbsp;Definicja&nbsp;typu&nbsp;zaczyna&nbsp;się&nbsp;od&nbsp;słowa&nbsp;kluczowego&nbsp;"Inductive".&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">bit</span> : <span class="id" title="keyword">Type</span> :=  <span class="comment">(*&nbsp;"bit"&nbsp;jest&nbsp;typem&nbsp;zdefiniowanym&nbsp;w&nbsp;ten&nbsp;sposób,&nbsp;że:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tak</span> : <span class="id" title="var">bit</span>  <span class="comment">(*&nbsp;"tak"&nbsp;jest&nbsp;elementem&nbsp;typu&nbsp;"bit"&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nie</span> : <span class="id" title="var">bit</span>. <span class="comment">(*&nbsp;"nie"&nbsp;jest&nbsp;elementem&nbsp;typu&nbsp;"bit"&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żeby Coq przeczytał powyższą definicję, kliknij na samej górze po prawej
    strzałkę w dół (lub wciśnij alt + strzałka w dół). Kiedy Coq jest w trakcie
    czytania definicji, jest ona podświetlona na pomarańczowo. Jeżeli Coq ją
    zaakceptuje, zostaje ona podświetlona na szaro. Jeżeli z definicją jest coś
    nie tak, to zostanie podświetlona na czerwono, a komunikat o błędzie pojawi
    się w oknie po prawej na dole.

<div class="paragraph"> </div>

    Powyższa definicja, jak widać, jest w porządku. Nie pytaj na razie, skąd
    słowo kluczowe <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> - dowiemy się tego później. Zauważ też, że
    definicja kończy się kropką, podobnie jak wszystkie inne komendy w Coqu.
    Samą definicję można odczytać następująco: "bit jest typem, który może
    przjmować tylko jedną z dwóch wartości: tak albo nie".

<div class="paragraph"> </div>

    Co można zrobić z bitem? Zanegować! Tzn. zamienić "1" na "0", a "0" na "1"
    (co w naszym przypadku oznacza, że chcemy zamienić <span class="inlinecode"><span class="id" title="var">tak</span></span> na <span class="inlinecode"><span class="id" title="var">nie</span></span>, a <span class="inlinecode"><span class="id" title="var">nie</span></span>
    na <span class="inlinecode"><span class="id" title="var">tak</span></span>). A zatem do dzieła. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span>                  <span class="comment">(*&nbsp;Definicja&nbsp;zaczyna&nbsp;się&nbsp;od&nbsp;słowa&nbsp;kluczowego&nbsp;"Definition".&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">negacja</span> : <span class="id" title="var">bit</span> -&gt; <span class="id" title="var">bit</span> :=   <span class="comment">(*&nbsp;negacja&nbsp;to&nbsp;funkcja,&nbsp;która&nbsp;bierze&nbsp;bit&nbsp;i&nbsp;zwraca&nbsp;bit,&nbsp;zdefiniowana&nbsp;następująco:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> : <span class="id" title="var">bit</span> =&gt;          <span class="comment">(*&nbsp;Weź&nbsp;jako&nbsp;argument&nbsp;bit&nbsp;nazwany&nbsp;<span class="inlinecode"><span class="id" title="var">b</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span>          <span class="comment">(*&nbsp;Sprawdź,&nbsp;jakiej&nbsp;<span class="inlinecode"><span class="id" title="var">b</span></span>&nbsp;jest&nbsp;postaci:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tak</span> =&gt; <span class="id" title="var">nie</span>      <span class="comment">(*&nbsp;Gdy&nbsp;<span class="inlinecode"><span class="id" title="var">b</span></span>&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">tak</span></span>,&nbsp;wynikiem&nbsp;funkcji&nbsp;jest&nbsp;<span class="inlinecode"><span class="id" title="var">nie</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nie</span> =&gt; <span class="id" title="var">tak</span>      <span class="comment">(*&nbsp;Gdy&nbsp;<span class="inlinecode"><span class="id" title="var">b</span></span>&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">nie</span></span>,&nbsp;wynikiem&nbsp;funkcji&nbsp;jest&nbsp;<span class="inlinecode"><span class="id" title="var">tak</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Uwaga: jeżeli oglądałeś moje nagranie z Dni Otwartych, to możesz tam
    zauważyć, że Coq automatycznie zamienia strzałkę <span class="inlinecode">-&gt;</span> na <span class="inlinecode">→</span>, <span class="inlinecode">=&gt;</span>
    na <span class="inlinecode">→</span>, <span class="inlinecode"><span class="id" title="keyword">fun</span></span> na <span class="inlinecode"><span class="id" title="var">λ</span></span>, a <span class="inlinecode"><span class="id" title="keyword">forall</span></span> na <span class="inlinecode">∀</span>. Żeby nie komplikować ci życia,
    na niniejszej stronie wyłączyłem te konwersje. 
<div class="paragraph"> </div>

<a id="lab4"></a><h1 class="section">Równość</h1>

<div class="paragraph"> </div>

 Czy nasza definicja negacji jest poprawna? Na razie nie wiadomo - musimy
    udowodnić jakieś twierdzenie, które nas w tym upewni. Zanim jednak to
    nastąpi, zobaczmy jak w ogóle działają w Coqu twierdzenia. Szczególnie
    zainteresowani będziemy dowodzeniem równości dwóch obiektów.

<div class="paragraph"> </div>

    Twierdzenia i dowody są jedną z najmocniejszych stron Coqa. Gdy zaczynamy
    dowód, w oknie po prawej pojawia się nasz cel, czyli to czego chcemy
    dowieść. W miarę jak wykonujemy kolejne kroki dowodu, stan okna po prawej
    zmienia się, żeby pokazać nam co musimy zrobić, co mamy do dyspozycji oraz
    co pozostało jeszcze do zrobienia. Każdy dowód możemy swobodnie przewijać
    w przód i w tył za pomocą strzałek na górze po prawej lub skrótów
    klawiszowych. Jeżeli nie rozumiesz jakiegoś dowodu, możesz powtarzać go,
    dopóki cię nie oświeci. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">tak</span> = <span class="id" title="var">tak</span>. <span class="comment">(*&nbsp;Po&nbsp;słowie&nbsp;kluczowym&nbsp;<span class="inlinecode"><span class="id" title="keyword">Goal</span></span>&nbsp;piszemy,&nbsp;co&nbsp;chcemy&nbsp;udowodnić.&nbsp;*)</span><br/>
<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;Dowód&nbsp;zaczynamy&nbsp;od&nbsp;słowa&nbsp;kluczowego&nbsp;<span class="inlinecode"><span class="id" title="keyword">Proof</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;Każda&nbsp;rzecz&nbsp;jest&nbsp;równa&nbsp;samej&nbsp;sobie&nbsp;i&nbsp;Coq&nbsp;o&nbsp;tym&nbsp;wie.&nbsp;*)</span><br/>
<span class="id" title="keyword">Qed</span>. <span class="comment">(*&nbsp;Dowód&nbsp;kończymy&nbsp;słowem&nbsp;<span class="inlinecode"><span class="id" title="keyword">Qed</span></span>&nbsp;-&nbsp;od&nbsp;łac.&nbsp;"Quod&nbsp;erat&nbsp;demonstrandum"&nbsp;-&nbsp;"Co&nbsp;należało&nbsp;udowodnić"&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> znaczy po angielsku "zwrotność", a "zwrotność" to w
    matematycznej mowie nazwa na fakt, że każda rzecz jest równa samej
    sobie - wiedział o tym już Arystoteles jakieś 2400 lat temu, więc
    i nie dziwota, że Coq o tym wie. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">tak</span> = <span class="id" title="var">nie</span>. <span class="comment">(*&nbsp;A&nbsp;może&nbsp;<span class="inlinecode"><span class="id" title="var">tak</span></span>&nbsp;jest&nbsp;równe&nbsp;<span class="inlinecode"><span class="id" title="var">nie</span></span>?&nbsp;Oby&nbsp;nie!&nbsp;*)</span><br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">tak</span></span>&nbsp;to&nbsp;coś&nbsp;innego&nbsp;niż <span class="inlinecode"><span class="id" title="var">nie</span></span>&nbsp;i&nbsp;Coq&nbsp;to&nbsp;wie&nbsp;-&nbsp;nie&nbsp;da&nbsp;się&nbsp;go&nbsp;zrobić&nbsp;w&nbsp;wała&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>. <span class="comment">(*&nbsp;Zakończenie&nbsp;dowodu&nbsp;za&nbsp;pomocą&nbsp;<span class="inlinecode"><span class="id" title="keyword">Abort</span></span>&nbsp;oznacza,&nbsp;że&nbsp;się&nbsp;poddajemy.&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> jest taktyką. Taktyka to formalny, Coqowy odpowiednik
    nieformalnego sposobu rozumowania. Powiedzenie, że "każda rzecz jest
    równa samej sobie", to właśnie taki nieformalny sposób rozumowania,
    a taktyka <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> jest jego realizacją. Nie każdy sposób
    rozumowania jest poprawny, a zatem nie każde użycie taktyki kończy
    się sukcesem. W powyższym przykładzie rozumowanie "tak to to samo
    co nie, bo każda rzecz jest równa samej sobie" jest niepoprawne, a
    zatem próba użycia taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> zawodzi i musimy się poddać. 
<div class="paragraph"> </div>

<a id="lab5"></a><h1 class="section">Obliczenia</h1>

<div class="paragraph"> </div>

 Obliczenia w Coqu są wykonywane w bardzo prosty sposób - wszystko
    sprowadza się do upraszczania wyrażeń. Uczyłeś się pewnie w szkole
    na matematyce, że 0 + x = x i że jeżeli mamy jakieś skomplikowane
    wyrażenie, w którym występuje 0 + x, to możemy to wyrażenie uprościć
    do postaci, w której zamiast 0 + x występuje samo x.

<div class="paragraph"> </div>

    Każdy program w Coqu jest po prostu wyrażeniem, a jego obliczanie
    polega na wykonywaniu po kolei różnych uproszczeń. Są trzy główne
    rodzaje uproszczeń: odwinięcie definicji, podstawienie wartości za
    argument funkcji, i wykonanie dopasowania do wzorca. W praktyce
    wygląda to tak: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">negacja</span> <span class="id" title="var">tak</span> = <span class="id" title="var">nie</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">delta</span>. <span class="comment">(*&nbsp;Pierwszym&nbsp;krokiem&nbsp;obliczeń&nbsp;jest&nbsp;odwinięcie&nbsp;definicji.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span>. <span class="comment">(*&nbsp;Kolejnym&nbsp;krokiem&nbsp;jest&nbsp;podstawienie&nbsp;wartości&nbsp;<span class="inlinecode"><span class="id" title="var">tak</span></span>&nbsp;za&nbsp;argument&nbsp;funkcji.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">iota</span>. <span class="comment">(*&nbsp;Ostatnim&nbsp;krokiem&nbsp;jest&nbsp;wykonanie&nbsp;dopasowania&nbsp;i&nbsp;zwrócenie&nbsp;odpowiedniej&nbsp;wartości.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="var">negacja</span> <span class="id" title="var">nie</span> = <span class="id" title="var">tak</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">cbv</span>. <span class="comment">(*&nbsp;Oczywiście&nbsp;możemy&nbsp;policzyć&nbsp;wszystko&nbsp;za&nbsp;jednym&nbsp;zamachem.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Taktyka <span class="inlinecode"><span class="id" title="tactic">cbv</span></span> realizuje sposób rozumowania "uprość program
    maksymalnie jak tylko się da". Nazwa pochodzi od angielskiego
    "call by value" i oznacza pewną konkretną kolejność, w której
    wykonywane są trzy podstawowe rodzaje uproszczeń, które
    widzieliśmy powyżej. 
<div class="paragraph"> </div>

<a id="lab6"></a><h1 class="section">Niebanalne twierdzenie</h1>

<div class="paragraph"> </div>

 No, wreszcie czas udowodnić coś o naszej negacji. Ale co? Cóż...
    gdyby tak zanegować jakiś bit dwa razy, to powinniśmy w wyniku
    otrzymać to samo, co mieliśmy na początku, czyż nie? 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bit</span>,         <span class="comment">(*&nbsp;Dla&nbsp;każdego&nbsp;bitu&nbsp;b...&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">negacja</span> (<span class="id" title="var">negacja</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>. <span class="comment">(*&nbsp;negacja&nbsp;negacji&nbsp;b&nbsp;jest&nbsp;równa&nbsp;b&nbsp;*)</span><br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">dowolne_b</span>. <span class="comment">(*&nbsp;Weźmy&nbsp;dowolny&nbsp;bit&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">dowolne_b</span>. <span class="comment">(*&nbsp;Analiza&nbsp;przypadków:&nbsp;bit&nbsp;może&nbsp;mieć&nbsp;jedną&nbsp;z&nbsp;dwóch&nbsp;postaci&nbsp;(tak/nie)&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span>. <span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;Trochę&nbsp;obliczeń&nbsp;i...&nbsp;udało&nbsp;się!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="comment">(*&nbsp;Nie&nbsp;musimy&nbsp;ręcznie&nbsp;prosić&nbsp;o&nbsp;policzenie&nbsp;-&nbsp;Coq&nbsp;sam&nbsp;wie,&nbsp;żeby&nbsp;to&nbsp;zrobić.&nbsp;*)</span><br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Nasze twierdzenie ma stosować się do każdego bitu <span class="inlinecode"><span class="id" title="var">b</span></span>, a więc nie możemy o
    tym bicie niczego założyć. Żeby to wyrazić, piszemy <span class="inlinecode"><span class="id" title="keyword">forall</span></span>, czyli po
    polsku "dla każdego".

<div class="paragraph"> </div>

    Żeby udowodnić coś o każdym bicie <span class="inlinecode"><span class="id" title="var">b</span></span>, wystarczy udowodnić to dla
    dowolnego bitu. Właśnie ten sposób rozumowania realizuje taktyka
    <span class="inlinecode"><span class="id" title="tactic">intros</span></span> (argument po <span class="inlinecode"><span class="id" title="tactic">intros</span></span> to nazwa, którą chcemy nadać naszemu
    dowolnemu bitowi). Po przeczytaniu linijki <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">dowolne_b</span>.</span> mamy
    spore zmiany w oknie po prawej - z naszego celu zniknęło <span class="inlinecode"><span class="id" title="keyword">forall</span></span>
    <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span>, zaś nad kreską pojawiła się linijka <span class="inlinecode"><span class="id" title="var">dowolne_b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span>.
    To, co znajduje się nad kreską, to kontekst - widać tam wszystkie
    nasze założenia, hipotezy oraz wszelkie inne obiekty, którymi możemy
    się posługiwać w trakcie dowodu.

<div class="paragraph"> </div>

    Następnie rozumujemy przez analizę przypadków. Ponieważ zdefiniowaliśmy
    bit mówiąc (a raczej pisząc), że każdy bit to albo <span class="inlinecode"><span class="id" title="var">tak</span></span> albo <span class="inlinecode"><span class="id" title="var">nie</span></span>, to
    rozpatrzenie tych dwóch przypadków z osobna wystarcza, by powiedzieć
    coś o dowolnym bicie. Właśnie ten sposób rozumowania jest realizowany
    przez taktykę <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. W wyniku użycia tej taktyki mamy tearz dwa
    cele: w pierwszy z nich <span class="inlinecode"><span class="id" title="var">dowolne_b</span></span> zostało zastąpione przez <span class="inlinecode"><span class="id" title="var">tak</span></span>, a w
    drugim przez <span class="inlinecode"><span class="id" title="var">nie</span></span>. W pierwszym przypadku wystarczy wykonać nieco obliczeń
    i widać wtedy, że obie strony równości są takie same. Drugi przypadek jest
    analogiczny - co więcej, jeżeli użyjemy tylko taktyki <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, to
    Coq sam połapie się, że powinien wykonać odpowiednie obliczenia.

<div class="paragraph"> </div>

    Tym sposobem udało nam się udowodnić nasze twierdzenie, choć być może nie
    wzbudza ono w tobie jakiegoś wybitnego entuzjazmu. Wszakże w Pythonie czy
    innym C++, aby upewnić się, czy tamtejsza negacja jest poprawna, wystarczy
    napisać dwa testy. Jeżeli oba przechodzą, można ogłosić sukces. 
<div class="paragraph"> </div>

<a id="lab7"></a><h1 class="section">Bardziej skomplikowane typy, funkcje rekurencyjne i dowody przez indukcję</h1>

<div class="paragraph"> </div>

 Czas więc, abyśmy ujrzeli jakiś bardziej skomplikowany przykład. Interesować
    będzie nas typ, który ma nieskończenie wiele elementów. Z pewnością w Pythonie
    czy C++ nie da się napisać nieskończenie wielu testów, prawda? W Coqu zaś
    można dowodzić właściwości programów operujących na takich typach bez żadnego
    problemu. Ponieważ w językach funkcyjnych najbardziej rozpowszechnioną
    strukturą danych są listy, to właśnie one będą naszym kolejnym przykładem -
    zdefiniujemy typ reprezentujący listy bitów, dwie proste funkcje operujące
    na listach, i udowodnimy, że są one poprawne. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">lista</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">koniec</span>      : <span class="id" title="var">lista</span>                  <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">koniec</span></span>&nbsp;jest&nbsp;listą&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> : <span class="id" title="var">bit</span> -&gt; <span class="id" title="var">lista</span> -&gt; <span class="id" title="var">lista</span>. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>&nbsp;jest&nbsp;listą,&nbsp;pod&nbsp;warunkiem&nbsp;że&nbsp;<span class="inlinecode"><span class="id" title="var">b</span></span>&nbsp;jest&nbsp;bitem&nbsp;a&nbsp;<span class="inlinecode"><span class="id" title="var">l</span></span>&nbsp;listą&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Najpierw trochę terminologii: to, co w definicji typu piszemy po pionowej
    kresce "|", to konstruktor. A zatem konstruktorami typu <span class="inlinecode"><span class="id" title="var">bit</span></span> są <span class="inlinecode"><span class="id" title="var">tak</span></span> i
    <span class="inlinecode"><span class="id" title="var">nie</span></span>, zaś konstruktorami typu <span class="inlinecode"><span class="id" title="var">lista</span></span> są <span class="inlinecode"><span class="id" title="var">koniec</span></span> i <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span>.
    Konstruktory danego typu służą do konstruowania jego elementów, stąd nazwa.
    Uwaga: konstruktory w Coqu nie mają nic wspólnego z konstruktorami znanymi
    z języków takich jak C++ czy Python - zbieżność nazw jest przypadkowa.

<div class="paragraph"> </div>

    Powyższą definicję możemy przeczytać w następujący sposób: każda lista to
    albo <span class="inlinecode"><span class="id" title="var">koniec</span></span>, albo <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span>, gdzie <span class="inlinecode"><span class="id" title="var">b</span></span> jest bitem, a <span class="inlinecode"><span class="id" title="var">l</span></span> listą.
    <span class="inlinecode"><span class="id" title="var">koniec</span></span> reprezentuje listę pustą (czyli taką, w której nie ma żadnych
    bitów), zaś <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> reprezentuje listę, która powstaje z dostawienia
    bitu <span class="inlinecode"><span class="id" title="var">b</span></span> na samym początku jakiejś innej listy <span class="inlinecode"><span class="id" title="var">l</span></span>. Elementy typu <span class="inlinecode"><span class="id" title="var">lista</span></span>
    mają się do bardziej tradycyjnego zapisu list (używającego kwadratowych nawiasów)
    następująco:
<ul class="doclist">
<li> Tradycyjnie: <span class="inlinecode">[]</span> (lista pusta). Po naszemu: <span class="inlinecode"><span class="id" title="var">koniec</span></span>.

</li>
<li> Tradycyjnie: <span class="inlinecode">[<span class="id" title="var">tak</span>]</span>. Po naszemu: <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span></span>.

</li>
<li> Tradycyjnie <span class="inlinecode">[<span class="id" title="var">nie</span>;</span> <span class="inlinecode"><span class="id" title="var">tak</span>]</span>. Po naszemu: <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">nie</span></span> <span class="inlinecode">(<span class="id" title="var">na</span></span> <span class="inlinecode"><span class="id" title="var">pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span>)</span>.

</li>
<li> I tak dalej... 
</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">tak</span> (<span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">nie</span> (<span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">tak</span> <span class="id" title="var">koniec</span>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;na_początku&nbsp;tak&nbsp;(na_początku&nbsp;nie&nbsp;(na_początku&nbsp;tak&nbsp;koniec))&nbsp;:&nbsp;lista&nbsp;*)</span><br/>

<br/>
</div>

<div class="doc">
Żebyś miał pewność, że nie robię cię w konia, możemy poprosić Coqa żeby
    sprawdził, jakiego typu jest dany obiekt. Służy do tego komenda <span class="inlinecode"><span class="id" title="keyword">Check</span></span>.
    W prawym dolnym rogu Coq wyświetla swoją odpowiedź: najpierw powtarza to co
    wpisaliśmy, a potem, po dwukropku, podaje nam typ obiektu. Jak widać, Coq
    sądzi, że to, co napisaliśmy powyżej, jest obiektem typu <span class="inlinecode"><span class="id" title="var">lista</span></span> (odpowiedź
    Coqa pozwoliłem sobie skopiować i wkleić powyżej w komentarzu po znaczniku
    "===&gt;"). Lista ta w tradycyjnym zapisie to <span class="inlinecode">[<span class="id" title="var">tak</span>;</span> <span class="inlinecode"><span class="id" title="var">nie</span>;</span> <span class="inlinecode"><span class="id" title="var">tak</span>]</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bit</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">lista</span>) : <span class="id" title="var">lista</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">koniec</span>           =&gt; <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">b</span> <span class="id" title="var">koniec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">c</span> <span class="id" title="var">l'</span> =&gt; <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">c</span> (<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span> <span class="id" title="var">b</span> <span class="id" title="var">l'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Skoro umiemy robić listy, dostawiając bit na początku, to dobrze byłoby
    też dowiedzieć się, jak dostawić bit na końcu listy. W tym celu definiujemy
    funkcję <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span>. Ta funkcja będzie rekurencyjna, więc definicję musimy
    zacząć od słowa kluczowego <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> (co znaczy słowo "fixpoint" i co ma
    wspólnego z rekurencją, nie pytaj...). <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> jest funkcją typu
    <span class="inlinecode"><span class="id" title="var">bit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">lista</span></span>, tzn. bierze jako argumenty bit oraz listę, a zwraca
    listę. Zapis jednak nieco różni się od tego, którego użyliśmy definiując
    funkcję <span class="inlinecode"><span class="id" title="var">negacja</span></span>. Zapis <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode">(<span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>)</span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>
    oznacza to samo, co
    <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>)</span> <span class="inlinecode">(<span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">...</span>,
    a jest dużo bardziej zwięzły, bo unikamy pisania typów dwa razy.

<div class="paragraph"> </div>

    Definicję zaczynamy od sprawdzenia, jakiej postaci jest lista <span class="inlinecode"><span class="id" title="var">l</span></span>. Opcje
    są dwie, tak jak wynika z definicji typu <span class="inlinecode"><span class="id" title="var">lista</span></span>. Gdy <span class="inlinecode"><span class="id" title="var">l</span></span> to <span class="inlinecode"><span class="id" title="var">koniec</span></span>,
    wynikiem jest <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span></span> - skoro doszliśmy do końca listy, to
    dostawienie bitu na końcu jest dokładnie tym samym, co dostawienie go na
    początku. Gdy <span class="inlinecode"><span class="id" title="var">l</span></span> to <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> dla jakiegoś <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span> oraz
    <span class="inlinecode"><span class="id" title="var">l'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span></span>, wynikiem jest <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">l'</span>)</span> - ponieważ bit
    chcemy dostawić na końcu, to początek listy pozostaje bez zmian. Co jednak
    z resztą listy, czyli z <span class="inlinecode"><span class="id" title="var">l'</span></span>? Musimy na jej końcu dostawić bit <span class="inlinecode"><span class="id" title="var">b</span></span>, a zrobić
    to możemy za pomocą funkcji <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span>...

<div class="paragraph"> </div>

    I to właśnie jest rekurencja - żeby zdefiniować funkcję <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span>, musimy
    użyć funkcji <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span>. Innymi słowy: funkcja <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> wywołuje samą
    siebie. Mogłoby się wydawać, że coś takiego jest nielegalne ("kręcimy się w
    kółko"), ale nic bardziej mylnego: każde wywołanie rekurencyjne bierze jako
    argument coraz mniejszą listę. Ponieważ każda lista jest skończona (mimo, że
    wszystkich list razem jest nieskończenie wiele), to wywołania rekurencyjne
    prędzej czy później skonsumują całą listę i trafimy na <span class="inlinecode"><span class="id" title="var">koniec</span></span>, a wtedy
    działanie funkcji się zakończy. Definicje rekurencyjne są więc w Coqu
    dozwolone. Ba! Są naszym jedynym wyjściem - nie mamy do dyspozycji żadnych
    pętli ani niczego takiego. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">odwró</span>ć (<span class="id" title="var">l</span> : <span class="id" title="var">lista</span>) : <span class="id" title="var">lista</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">koniec</span>           =&gt; <span class="id" title="var">koniec</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">b</span> <span class="id" title="var">l'</span> =&gt; <span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span> <span class="id" title="var">b</span> (<span class="id" title="var">odwró</span>ć <span class="id" title="var">l'</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Kolejną funkcją, którą chcemy zdefiniować, jest funkcja <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span>, której
    zadaniem jest odwrócenie listy tak, żeby początek był na końcu, a koniec
    na początku. <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> jest typu <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">lista</span></span>, czyli bierze listę oraz
    zwraca listę. Podobnie jak <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> (i prawie wszystkie inne definicje
    funkcji operaujących na listach), definicja jest rekurencyjna. Najpierw
    sprawdzamy, jakiej postaci jest argument <span class="inlinecode"><span class="id" title="var">l</span></span>. Gdy <span class="inlinecode"><span class="id" title="var">l</span></span> to <span class="inlinecode"><span class="id" title="var">koniec</span></span>, wynikiem
    również jest <span class="inlinecode"><span class="id" title="var">koniec</span></span> - gdy nie ma na liście żadnych bitów, nie ma czego
    odwracać. Jeżeli <span class="inlinecode"><span class="id" title="var">l</span></span> jest postaci <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> dla <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span> oraz 
    <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span></span>, to początkowy bit <span class="inlinecode"><span class="id" title="var">b</span></span> musi powędrować na koniec wynikowej listy -
    możemy wysłać go tam za pomocą funkcji <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> - zaś reszta listy (czyli
    <span class="inlinecode"><span class="id" title="var">l'</span></span>) musi zostać rekurencyjnie odwrócona, za pomocą funkcji <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">odwró</span>ć<span class="id" title="var">_na_ko</span>ń<span class="id" title="var">cu</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bit</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">lista</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">odwró</span>ć (<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span> <span class="id" title="var">b</span> <span class="id" title="var">l</span>) = <span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span> <span class="id" title="var">b</span> (<span class="id" title="var">odwró</span>ć <span class="id" title="var">l</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span> <span class="id" title="var">ogon_l</span> <span class="id" title="var">hipoteza_indukcyjna</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">hipoteza_indukcyjna</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Czas w końcu udowodnić jakieś twierdzenie. Tym razem zaczynamy od słowa
    kluczowego <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> - jest ono konieczne, jeżeli chcemy móc nazwać nasze
    twierdzenie. A chcemy - żeby móc się do niego później odnosić. Twierdzenie
    nazywamy <span class="inlinecode"><span class="id" title="var">odwró</span>ć<span class="id" title="var">_na_ko</span>ń<span class="id" title="var">cu</span></span>, bo chcemy się przekonać, co się stanie, gdy
    najpierw dostawimy bit <span class="inlinecode"><span class="id" title="var">b</span></span> na końcu listy <span class="inlinecode"><span class="id" title="var">l</span></span>, a potem całość odwrócimy.
    Odpowiedź jest prosta: oczywiście bit <span class="inlinecode"><span class="id" title="var">b</span></span> trafi na początek odwróconej
    listy <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    Zaczynamy od <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, czyli "weźmy dowolne b". Następnym krokiem jest
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">...</span>, co możemy przeczytać jako "indukcja po l". Indukcja to
    taka analiza przypadków na sterydach - w niektórych przypadkach do naszej
    dyspozycji dostajemy dodatkowo hipotezę indukcyjną. Indukcja jest sposobem
    rozumowania niezbędnym, gdy w grę wchodzą funkcje rekurencyjne. Ponieważ
    funkcja rekurencyjna wywołuje samą siebie na mniejszym argumencie, to żeby
    udowodnić coś na jej temat dla jakiegoś argumentu, najpierw trzeba udowodnić
    tę samą własność dla mniejszego argumentu. Widzimy więc, że potrzebne jest
    nam coś w stylu wywołania rekurencyjnego, tylko że chcemy użyć tego czegoś
    do dowodzenia, a nie do definiowania funkcji... i właśnie tym czymś jest
    hipoteza indukcyjna!

<div class="paragraph"> </div>

    Uwaga: klauzula <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode">[|</span> <span class="inlinecode"><span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span></span> <span class="inlinecode"><span class="id" title="var">ogon_l</span></span> <span class="inlinecode"><span class="id" title="var">hipoteza</span></span> <span class="inlinecode"><span class="id" title="var">indukcyjna</span>]</span> pozwala nam
    nadać nazwy rzeczom powstałym z rozłożenia <span class="inlinecode"><span class="id" title="var">l</span></span> na kawałki oraz hipotezie
    indukcyjnej. W programowaniu funkcyjnym tradycyjnie pierwszy element listy
    nazywa się głową, zaś resztę ogonem, i stąd biorą się nasze nazwy.

<div class="paragraph"> </div>

    Indukcja pozostawia nam do udowodnienia dwa przypadki. W pierwszym <span class="inlinecode"><span class="id" title="var">l</span></span>
    jest  postaci <span class="inlinecode"><span class="id" title="var">koniec</span></span>, a dowód jest prosty - po obu stronach równania
    jest to samo. W drugim przypadku same obliczenia już nie wystarczą, ale
    z pomocą przychodzi nam hipoteza indukcyjna, która jest równaniem postaci
    <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>)</span> - jest to
    niemal dokładnie ta właściwość, którą chcemy udowodnić, ale dotyczy ona
    ogona <span class="inlinecode"><span class="id" title="var">l</span></span>, a nie samej listy <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

    Zauważmy, że nasz cel również jest równaniem, zaś po jego lewej stronie
    mamy <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span></span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>))</span>. Ponieważ występuje
    tutaj wyrażenie <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>)</span>, to możemy użyć naszej hipotezy
    indukcyjnej, żeby zastąpić je przez <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>)</span>. Żeby
    to zrobić, używamy taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">hipoteza_indukcyjna</span></span>, która realizuje
    rozumowania polegające na przepisywaniu równań. Na koniec wystarczy trochę
    policzyć i voilà - widać, że obie strony równania są takie same. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">odwró</span>ć<span class="id" title="var">_odwró</span>ć :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">lista</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">odwró</span>ć (<span class="id" title="var">odwró</span>ć <span class="id" title="var">l</span>) = <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span> <span class="id" title="var">ogon_l</span> <span class="id" title="var">hipoteza_indukcyjna</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">odwró</span>ć<span class="id" title="var">_na_ko</span>ń<span class="id" title="var">cu</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">hipoteza_indukcyjna</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Udowodnijmy jeszcze, że dwukrotne odwrócenie listy daje w wyniku tę samą
    listę. Dowód, podobnie jak poprzednio, jest przez indukcję po <span class="inlinecode"><span class="id" title="var">l</span></span>. W tym
    momencie nie powinno nas to już dziwić - ponieważ prawie wszystkie funkcje
    operujące na listach są rekurencyjne, a dowodzenie właściwości funkcji
    rekurencyjnych wymaga rozumowania indukcyjnego, to prawie wszystkie dowody
    dotyczące list będą szły przez indukcję. Zauważmy też, że nie musimy dowodu
    zaczynąć taktyką <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> - gdy używamy indukcji, Coq sam wie, że powinien
    najpierw wprowadzić listę <span class="inlinecode"><span class="id" title="var">l</span></span> do kontekstu.

<div class="paragraph"> </div>

    Mamy do rozpatrzenia dwa przypadki. Gdy <span class="inlinecode"><span class="id" title="var">l</span></span> jest postaci <span class="inlinecode"><span class="id" title="var">koniec</span></span>, wystarczy
    trochę policzyć by przekonać się, że faktycznie <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode"><span class="id" title="var">koniec</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">koniec</span></span>.
    W drugim przypadku po wykonaniu obliczeń musimy pokazać
    <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span></span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">g</span>ł<span class="id" title="var">owa_l</span></span> <span class="inlinecode"><span class="id" title="var">ogon_l</span></span>.
    Zauważmy, że możemy skorzystać z udowodnionego uprzednio twierdzenia
    <span class="inlinecode"><span class="id" title="var">odwró</span>ć<span class="id" title="var">_na_ko</span>ń<span class="id" title="var">cu</span></span>, gdyż nasz celu zawiera wyrażenie postaci
    <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode">...)</span>. Ponieważ twierdzenie <span class="inlinecode"><span class="id" title="var">odwró</span>ć<span class="id" title="var">_na_ko</span>ń<span class="id" title="var">cu</span></span> jest po
    prostu równaniem, możemy użyć go za pomocą taktyki <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>. Gdy już to
    zrobimy, po lewej stronie w naszym celu ukazuje się wyrażenie
    <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">odwró</span>ć</span> <span class="inlinecode"><span class="id" title="var">ogon_l</span>)</span>, które możemy uprościć korzystając z hipotezy
    indukcyjnej. I to by było na tyle, bo po obu stronach równania widzimy
    dokładnie to samo. 
<div class="paragraph"> </div>

<a id="lab8"></a><h1 class="section">Dlaczego warto nauczyć się Coqa?</h1>

<div class="paragraph"> </div>

 Uważam, że warto nauczyć się Coqa (byłoby głupio, gdybym uważał inaczej,
    prawda?). Powodów jest kilka.

<div class="paragraph"> </div>

    Po pierwsze, programowanie funkcyjne ekspanduje i jest go wszędzie coraz
    więcej. Języki funkcyjne używane są coraz powszechniej (zdaje się, że
    najszybciej z nich rośnie Scala). Języki nie-funkcyjne natomiast w coraz
    większym stopniu pożyczają z języków funkcyjnych nowe konstrukty językowe
    (jeszcze kilka lat temu w C++ czy C nie było np. funkcji anonimowych),
    style i sposoby programowania (przetwarzanie strumieni w Javie),   Sprawa ma się tutaj w przybliżeniu dość
    prosto: jeżeli znasz jeden język funkcyjny, mniej więcej znasz je wszystkie.
    


 
<div class="paragraph"> </div>

<a id="lab9"></a><h1 class="section">Ćwiczenia</h1>

<div class="paragraph"> </div>

 Jeżeli dobrnąłeś aż tutaj, to gratuluję - znaczy, że musisz być całkiem
    wytrwały, a na dodatek zainteresowany tematem. Żeby nabyta w trakcie
    czytania wiedza nie uleciała, a entuzjazm nie opadł, proponuję żebyś
    wykonał parę łatwiutkich ćwiczeń.

<div class="paragraph"> </div>

    Oczywiście jak nie chcesz, to nie musisz robić ćwiczeń - nikt cię nie
    zmusza. To tylko taka dobra rada... 
<div class="paragraph"> </div>

<a id="lab10"></a><h4 class="section">Funkcja <span class="inlinecode"><span class="id" title="var">lub</span></span></h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">bit</span></span>, która zwraca <span class="inlinecode"><span class="id" title="var">tak</span></span>, gdy co
    najmniej jeden z jej argumentów jest równy <span class="inlinecode"><span class="id" title="var">tak</span></span>, zaś <span class="inlinecode"><span class="id" title="var">nie</span></span> w przeciwnym
    wypadku.

<div class="paragraph"> </div>

    Zanim zabierzesz się za następne zadanie, spróbuj wymyślić i udowodnić
    jakieś twierdzenie, które upewni cię, że twoja definicja jest poprawna. 
<div class="paragraph"> </div>

<a id="lab11"></a><h4 class="section">Właściwości funkcji <span class="inlinecode"><span class="id" title="var">lub</span></span> - zadania zamknięte</h4>

<div class="paragraph"> </div>

 Udowodnij podstawowe właściwości funkcji <span class="inlinecode"><span class="id" title="var">lub</span></span>:
<ul class="doclist">
<li> Idempotencja: <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span>

</li>
<li> Przemienność: <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span>

</li>
<li> Łączność: <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode">(<span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">(<span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="var">c</span>)</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab12"></a><h4 class="section">Właściwości funkcji <span class="inlinecode"><span class="id" title="var">lub</span></span> - zadania otwarte</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia, zamieniając uprzednio symbol <span class="inlinecode">?</span> na jakieś
    konkretne wyrażenie:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">nie</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">nie</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">(<span class="id" title="var">negacja</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>,</span> <span class="inlinecode"><span class="id" title="var">negacja</span></span> <span class="inlinecode">(<span class="id" title="var">lub</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">?</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab13"></a><h4 class="section">Funkcja <span class="inlinecode"><span class="id" title="var">sklej</span></span></h4>

<div class="paragraph"> </div>

 Zdefiniuj funkcję <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span></span> <span class="inlinecode">-&gt; <span class="id" title="var">lista</span></span> <span class="inlinecode">-&gt; <span class="id" title="var">lista</span></span>, które bierze dwie listy i
    skleja je ze sobą, np.

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode">(<span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span>)</span> <span class="inlinecode">(<span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">nie</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span>)</span>
    <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">tak</span></span> <span class="inlinecode">(<span class="id" title="var">na_pocz</span>ą<span class="id" title="var">tku</span></span> <span class="inlinecode"><span class="id" title="var">nie</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span>)</span>

<div class="paragraph"> </div>

    Innymi słowy: <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> zwraca listę, której początkiem jest lista <span class="inlinecode"><span class="id" title="var">l1</span></span>,
    zaś końcem lista <span class="inlinecode"><span class="id" title="var">l2</span></span>.

<div class="paragraph"> </div>

    Zanim zabierzesz się za następne zadanie, spróbuj wymyślić i udowodnić
    jakieś twierdzenie, które upewni cię, że twoja definicja jest poprawna. 
<div class="paragraph"> </div>

<a id="lab14"></a><h4 class="section">Właściwości funkcji <span class="inlinecode"><span class="id" title="var">sklej</span></span> - zadania zamknięte</h4>

<div class="paragraph"> </div>

 Udowodnij podstawowe właściwości funkcji <span class="inlinecode"><span class="id" title="var">sklej</span></span>:
<ul class="doclist">
<li> Łączność: <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>,</span> <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode">(<span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode"><span class="id" title="var">l3</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode">(<span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> <span class="inlinecode"><span class="id" title="var">l3</span>)</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab15"></a><h4 class="section">Właściwości funkcji <span class="inlinecode"><span class="id" title="var">sklej</span></span> - zadania otwarte</h4>

<div class="paragraph"> </div>

 Udowodnij poniższe twierdzenia, zamieniając uprzednio symbol <span class="inlinecode">?</span> na jakieś
    konkretne wyrażenie:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>,</span> <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>,</span> <span class="inlinecode"><span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode"><span class="id" title="var">koniec</span></span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">bit</span>)</span> <span class="inlinecode">(<span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>),</span> <span class="inlinecode"><span class="id" title="var">na_ko</span>ń<span class="id" title="var">cu</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">(<span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">?</span>

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">lista</span>,</span> <span class="inlinecode"><span class="id" title="var">odwró</span>ć</span> <span class="inlinecode">(<span class="id" title="var">sklej</span></span> <span class="inlinecode"><span class="id" title="var">l1</span></span> <span class="inlinecode"><span class="id" title="var">l2</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode">?</span> 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab16"></a><h1 class="section">Co dalej?</h1>

<div class="paragraph"> </div>

<a id="lab17"></a><h2 class="section">Środowisko</h2>

<div class="paragraph"> </div>

 Najłatwiej jest zapoznać się z Coqiem używając przeglądarkowego środowiska
    jsCoq (https://jscoq.github.io/scratchpad.html). Polecam - nie trzeba nic
    instalować i ma rozsądne podpowiadanie składni dla początkujących.

<div class="paragraph"> </div>

    Jeżeli chcesz zacząć dłuższą przygodę z Coqiem, polecam go zainstalować
    (https://coq.inria.fr/) - śmiga wtedy lepiej niż w przeglądarce. Musicie
    też wybrać sobie jakieś IDE:
<ul class="doclist">
<li> CoqIDE (https://coq.inria.fr/) - standardowe IDE do Coqa, polecam.

</li>
<li> Visual Studio Code (https://code.visualstudio.com/) z pluginem dla
      Coqa - również całkiem spoko.

</li>
<li> Emacs (https://www.gnu.org/software/emacs/) z pluginem Proof General
      (https://proofgeneral.github.io/) - nie polecam.

</li>
<li> W ostateczności można też używać Coqa z poziomu konsoli, ale tym
      bardziej nie polecam. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab18"></a><h2 class="section">Materiały dydaktyczne</h2>

<div class="paragraph"> </div>

 Przyda ci się też trochę materiałów dydaktycznych:
<ul class="doclist">
<li> Nagranie z zeszłorocznych dni otwartych (po polsku, ok. 20 min):
      https://www.youtube.com/watch?v=njgUPWlWYUM&amp;t=6936s

</li>
<li> Nagranie z prezentacji podobnej do naszej (po angielsku, 3 godziny):
      https://www.youtube.com/watch?v=5e7UdWzITyQ

</li>
<li> Książka Software Foundations, pierwsza połowa pierwszego tomu
      (po angielsku): https://softwarefoundations.cis.upenn.edu/lf-current/toc.html

</li>
</ul>

<div class="paragraph"> </div>

    Jeżeli słuchanie/czytanie po angielsku sprawia ci problem, możesz też przeczytać
    pierwsze rozdziały mojej własnej twórczości: https://wkolowski.github.io/CoqBookPL/
    (uwaga, dość niekompletna i trochę nie po kolei; nie jest też tak odpicowana, jak
    niniejsza notatka). 
<div class="paragraph"> </div>

<a id="lab19"></a><h2 class="section">Przydatne linki</h2>

<div class="paragraph"> </div>

 Poniższe linki stanowią dobre punkty wyjścia do rozpoczęcia eksploracji
    Coqowego świata:
<ul class="doclist">
<li> Strona domowa: https://coq.inria.fr/

</li>
<li> GitHub: https://github.com/coq/coq

</li>
<li> Forum: https://coq.discourse.group/

</li>
<li> Czat: https://coq.zulipchat.com/login/

</li>
<li> Q&amp;A: https://stackoverflow.com/questions/tagged/coq

</li>
</ul>

<div class="paragraph"> </div>

    Na stronie domowej znajdziesz więcej linków i materiałów dydaktycznych. Na
    GitHubie możesz podejrzeć, co Coqowi siedzi we flakach. Forum i tag "coq"
    na StackOverflow służą głównie do zadawania pytań. Nie wiem co dzieje się
    na czacie, ale pewnie też pytania, tylko że szybciej odpowiadają : ) 
<div class="paragraph"> </div>

<a id="lab20"></a><h2 class="section">Kontakt</h2>

<div class="paragraph"> </div>

  Jeżeli masz pytania, pisz śmiało:
<ul class="doclist">
<li> Ja: 299899@uwr.edu.pl

</li>
<li> Nie ja: tomasz.drab@cs.uni.wroc.pl 
</li>
</ul>

</div>
<div class="code">
</div>
<footer>
  <script src="ui-js/jscoq-loader.js"></script>
  <script src="jscoq-embed.js"></script>
</footer>
</body>
